---
title: Binding Beans to Forms
order: 4
layout: page
---

= Binding Beans to Forms

Business objects are typically implemented as JavaBeans in an application. `Binder` is used to tie the properties of a business object to UI components in your forms.

== Manual Data Binding

=== Using Bean Property Names

You can use reflection based on bean property names to bind values. This reduces the amount of code needed when binding to fields in the bean.

*Examples*: Binding using reflection based on bean property names.

[source, java]
----
Binder<Person> binder = new Binder<>(Person.class);

// Bind based on property name
binder.bind(nameField, "name");
// Bind based on sub property path
binder.bind(streetAddressField, "address.street");
// Bind using forField for additional configuration
binder.forField(yearOfBirthField)
  .withConverter(
    new StringToIntegerConverter("Please enter a number"))
  .bind("yearOfBirth");
----

[NOTE]
Be cautious when using strings to identify properties. A typo in the string, or a subsequent changes to the setter and getter method names, will result in a runtime exception.

=== Using JSR 303 Bean Validation

You can use `BeanValidationBinder` if you prefer to use JSR 303 Bean Validation annotations such as `Max`, `Min`, `Size`, etc.

`BeanValidationBinder` extends `Binder`, and therefore has the same API, but its implementation automatically adds a bean validator which takes care of all JSR 303 constraints.

To use Bean Validation annotations, you need a JSR 303 implementation like Hibernate Validator available in your classpath. If your environment, such as Java EE container, does not provide the implementation, you can use the following dependency in Maven:

[source, xml]
----
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>5.4.1.Final</version>
</dependency>
----

==== Defining Constraints for Specific Properties

*Example*: Using JSR 303 Bean Validation annotations with `BeanValidationBinder`

[source, java]
----
public class Person {
    @Max(2000)
    private int yearOfBirth;

    //Non-standard constraint provided by Hibernate Validator
    @NotEmpty
    private String name;

    // + other fields, constructors, setters, and getters
}

BeanValidationBinder<Person> binder = new BeanValidationBinder<>(Person.class);

binder.bind(nameField, "name");
binder.forField(yearOfBirthField)
  .withConverter(
    new StringToIntegerConverter("Please enter a number"))
  .bind("yearOfBirth");
----

Constraints defined for properties in the bean, work in the same way as if configured when the binding is created. For example, the following code snippets have the same result:

*Example*: Bean Validation annotation.

[source, java]
----
public class Person {
    @Max(value = 2000, message = "Year of Birth must be less than or equal to 2000")
    private int yearOfBirth;
----
*Example*: Binder validation.

[source, java]
----
binder.forField(yearOfBirthField)
  .withValidator(
    yearOfBirth -> yearOfBirth <= 2000,
    "Year of Birth must be less than or equal to 2000")
  .bind(Person::getYearOfBirth, Person::setYearOfBirth);
----

==== Defining Constraints on the Bean Level

// The original text was difficult to understand. I copied this code example from the Hibernate docs and referenced them as the source. The original text just linked to the example. We could leave it like this or amend the code. I'm very unsure about the explanation here.   

As an alternative to defining constraint annotations for specific properties, you can define constraints on the bean level.

*Example*: Defining bean-level constraint annotations. _Source: https://docs.jboss.org/hibernate/validator/5.4/reference/en-US/html_single/#validator-gettingstarted-createmodel[Hibernate Validator 5.4.2 - Applying constraints]_

[source, java]
----
package org.hibernate.validator.referenceguide.chapter01;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}
----

The previous example automatically enables the visual "required" indicator using `HasValue.setRequiredIndicatorVisible(true)`. By default `@NotNull`, `@NotEmpty` and `@Size` (if `min()` value is greater than 0) configures the field as required. You can change this behavior using the `BeanValidationBinder.setRequiredConfigurator` method.

*Example*: Overriding the default `@Size` behavior. 

[source, java]
----
binder.setRequiredConfigurator(RequiredFieldConfigurator.NOT_EMPTY.chain(RequiredFieldConfigurator.NOT_NULL));
----

[NOTE]
When you use the `setBean` method (unbuffered binding), validation is triggered automatically on all change events. When you use the `readBean` and `writeBean` methods (unbuffered binding), validation is only triggered automatically when calling `writeBean`. You can trigger it manually at any time by calling `validate()` on the `Binder`, for example in a `ValueChange` handler.

Validation errors resulting from bean-level validation may not be directly associated with a field component in the UI. For this reason, `Binder` may not know where to display the messages. You can overcome this, by defining a `Label` for status messages that are not related to specific fields. This is similar to the `withStatusLabel` method that is used to define where messages for a specific binding should be displayed.

*Example*: Defining a `formStatusLabel`.

[source, java]
----
Label formStatusLabel = new Label();

Binder<Person> binder = new Binder<>(Person.class);

binder.setStatusLabel(formStatusLabel);

// Continue by binding fields
----

You can also define a status handler for custom status handling.

*Example*: Defining a custom status handler. 

[source, java]
----
BinderValidationStatusHandler<Person> defaultHandler = binder
                .getValidationStatusHandler();

binder.setValidationStatusHandler(status -> {
    // create an error message on failed bean-level validations
    List<ValidationResult> errors = status
            .getBeanValidationErrors();

    // collect all bean-level error messages into a single string,
    // separate each message with a <br> tag
    String errorMessage = errors.stream()
            .map(ValidationResult::getErrorMessage)
            // sanitize the individual error strings to avoid code
            // injection
            // since we are displaying the resulting string as HTML
            .map(errorString -> Jsoup.clean(errorString,
                    Whitelist.simpleText()))
            .collect(Collectors.joining("<br>"));

    // finally, display all bean-level validation errors in a single
    // label
    formStatusLabel.getElement().setProperty("innerHTML", errorMessage);
    setVisible(formStatusLabel, !errorMessage.isEmpty());

    // Let the default handler show messages for each field
    defaultHandler.statusChange(status);
});
----

== Automatic Data Binding

The `bindInstanceFields` method facilitates automatic data binding. 

UI fields are typically defined as members of a UI Java class. This allows you to access the fields easily using the different methods made available by the class. In this scenario, binding the fields is also simple, because when you pass the object to the UI class, the `bindInstanceFields` method matches the fields of the object to the properties of the related business object, based on their names.

*Example*: Using the `bindInstanceFields` method to bind all fields in a UI class.

[source, java]
----
public class MyForm extends VerticalLayout {
    private TextField firstName = new TextField("First name");
    private TextField lastName = new TextField("Last name");
    private ComboBox<Gender> gender = new ComboBox<>("Gender");

    public MyForm() {
        Binder<Person> binder = new Binder<>(Person.class);
        binder.bindInstanceFields(this);
    }
}
----

* This binds the `firstName` text field to the "firstName" property in the item,
`lastName` text field to the “lastName” property, and the `gender` combo box to the “gender” property.

Without this method, it would be necessary to bind each field separately. 

*Example*: Binding each field separately. 

[source, java]
----
binder.forField(firstName)
    .bind(Person::getFirstName, Person::setFirstName);
binder.forField(lastName)
    .bind(Person::getLastName, Person::setLastName);
binder.forField(gender)
    .bind(Person::getGender, Person::setGender);
----

=== Specifying Property Names

The `bindInstanceFields` method processes all Java member fields with a type that extends `HasValue` (such as `TextField`) that can be mapped to a property name. 

If the field name does not match the corresponding property name in the business object, you  can use the `@PropertyId` annotation to specify the property name. 

*Example*: Using the `@PropertyId` annotation to specify the "sex" property for the `gender` field. 

[source, java]
----
@PropertyId("sex")
private ComboBox<Gender> gender = new ComboBox<>("Gender");
----

=== Converting Value Types

The `bindInstanceFields` method does not automatically add a converter to the binding. For this reason, if the value type of the field does not match the property type, it may not be possible to automatically bind a field to its corresponding property. For example, an "age” `TextField` (with a String value type), and an “age” property in the `Person` class (with an Integer property type), will throw an `IllegalStateException` when calling `bindInstanceFields`. 

You can prevent this exception by manually specifying a converter before calling the `bindInstanceFields` method.

*Example*: Manually specifying `StringToIntegerConverter` before calling the `bindInstanceFields` method. 

[source, java]
----
TextField yearOfBirthField = new TextField("Year of birth");

binder.forField(yearOfBirthField)
.withConverter(
       new StringToIntegerConverter("Must enter a number"))
.bind(Person::getYearOfBirth, Person::setYearOfBirth);

binder.bindInstanceFields(this);

----

=== Validating Fields

The `bindInstanceFields` method does not support validation. If you want to add validation, use `BeanValidationBinder` instead of the `bindInstanceFields` method.
