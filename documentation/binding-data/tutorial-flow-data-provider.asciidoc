---
title: Binding Data Items to Components
order: 5
layout: page
---

= Binding Data Items to Components

In most applications, there are lists of items shown to end-users. This can be implemented using either basic components with `for` loops, or using components, such as `Grid`, `ComboBox`, and `ListBox`, that are designed for that purpose.

All listing components in Vaadin have a set of `setItems` methods to define which items to display. Items can be basic objects, like strings or numbers, or POJOs, such as DTOs or JPA entities, from your domain model. The easiest way is just to provide a `java.util.List` of objects to be shown in the component.

If the number of items is large and reserves a lot of memory, `Grid` and `ComboBox` allow you to do a lazy data binding using callbacks to fetch only the required set of items from the back-end.

== Configuring how items are displayed

There are component-specific APIs to adjust how items are displayed. Many select components use the `toString()` method to display items by default. If this is not suitable, you can change the behavior by configuring the component. Components are configured with one or more callbacks that define how to display the items.

*Example*: Examples of configuring how items are displayed. A `ComboBox` component that lists status items and uses the `Status.getLabel()` method to represent each status. There is also a `Grid` with two columns, Name and Year of birth, and another `Grid` that shows three properties from the Person Java Bean.

[source, java]
----
ComboBox<Status> comboBox = new ComboBox<>();
comboBox.setItemLabelGenerator(Status::getLabel);

Grid<Person> grid = new Grid<>();
grid.addColumn(Person::getName).setHeader("Name");
grid.addColumn(Person::getYearOfBirth)
        .setHeader("Year of birth");

Grid<Person> grid = new Grid<>(Person.class);
grid.setColumns("name", "email", "title");

----

Check the component examples for more details on configuring how the listed data is displayed.

== Assigning a List or Array of in-memory data

The easiest way to pass data to the listing component is to use an array or `java.util.List`. You can create those data structures easily by yourself or pass values directly from your service layer.

*Example*: Passing in-memory data to components using the `setItems` method.

[source, java]
----
// Sets items as a collection
comboBox.setItems(EnumSet.allOf(Status.class));

// Sets items using varargs
grid.setItems(
        new Person("George Washington", 1732),
        new Person("John Adams", 1735),
        new Person("Thomas Jefferson", 1743),
        new Person("James Madison", 1751)
);

// Pass all Person objects to a grid from a Spring Data repository object
grid.setItems(personRepository.findAll());
----

=== Sorting of In-memory Data in Grid

Grid rows are automatically sortable by columns whose property type implements `Comparable`. By defining a custom `Comparator` you can make other columns comparable or override the default behavior.

*Example*: Defining a custom comparator.

[source, java]
----
grid.addColumn(Person::getName)
        .setHeader("Name")
        // Override default natural sorting
        .setComparator(Comparator.comparing(person ->
                    person.getName().toLowerCase()));
----

[NOTE]
This kind of sorting is only supported for in-memory data. See <<Sorting with Lazy Data Binding>> for how to sort lazy-loaded data.

You can also sort the items collection with `DataView` API, either by setting a `Comparator` or a sort order for a given bean field. Sort orders or `Comparator` can be added or removed completely as well.

*Example*: Defining a custom sorting via a `DataView` API:

[source, java]
----
GridListDataView<Person> dataView = grid.setItems(personRepository.findAll());

// Change the sort order of items collection
dataView.setSortOrder(Person::getName, SortDirection.ASCENDING);

// Add a sort order of items collection to an existing sorting
dataView.addSortOrder(Person::getTitle, SortDirection.ASCENDING);

// Remove item collection sorting completely
dataView.removeSorting();
----

== Making a Lazy Data Binding to Grid Using Callbacks

A more advanced way to bind data to components is using callback methods. This way, only the required portion of the data is loaded from your backend to the server memory. This approach is harder to implement and provides fewer features out of the box but can save a lot of resources in the backend and the UI server. The component gives a query object as a parameter to your callback methods, where you can check that what part of the data set is needed.

Currently, only `Grid` and `ComboBox` properly support lazy data binding.

*Example*: Doing a lazy data binding to Grid

[source, java]
----
grid.setItems(query -> { // <1>
    return getPersonService() // <2>
        .fetchPersons(query.getOffset(), query.getLimit()) // <3>
        .stream(); // <4>
});
----

<1> To create a lazy binding, use an overloaded version of the `setItems` method that uses a callback instead of passing data directly to the component
<2> Typically you call your service layer from the callback - as in this example
<3> Use the query object's parameters to limit the data you pass from the backend to the component
<4> The callbacks return the data as a `java.util.Stream`. In this example, the backend returns a `List`, so we need to convert it to a `Stream`.

The example above suits naturally for JDBC backends where you can request a set of rows from a given index. Vaadin calls your data binding call in paged manner, so it is possible to bind also to "Paging backends", such as Spring Data based solutions.

*<Example*: Doing a lazy data-binding from a Spring Data Repository to Grid

[source, java]
----
grid.setItems(query -> {
    return repository.findAll( // <1>
            PageRequest.of(query.getPage(), // <2>
                    query.getPageSize()) // <3>
    ).stream(); // <4>
});
----

<1> In this example we call Spring Data repository to find the requested result set
<2> The query object contains a shorthand for zero based page index.
<3> The query object also contains page size.
<4> Return a stream of items from the Spring Data `Page` object

=== Sorting with Lazy Data Binding

For efficient lazy data-binding, sorting needs to happen in the backend too. By default, Grid makes all columns appear sortable in the UI, but you'll need to manually declare which columns are actually sortable. Otherwise the UI may indicate that some columns is sortable, although nothing happens if you try to sort it. In the lazy data binding, you'll need to pass the hints Grid provides in the Query object somehow to your backend logic.

*Example*: A sortable lazy data-binding to a Spring Data repository

[source, java]
----
public void bindWithSorting() {
    Grid<Person> grid = new Grid<>(Person.class);
    grid.setSortableColumns("name", "email"); // <1>
    grid.addColumn(person -> person.getTitle())
        .setHeader("Title")
        	.setKey("title").setSortable(true); // <2>
    grid.setItems(
        q -> {
            Sort springSort = toSpringDataSort(q.getSortOrders()); // <3>
            return repo.findAll(
                    PageRequest.of(
                            q.getPage(), 
                            q.getPageSize(), 
                            springSort // <4>
            )).stream();
    });
}

/**
 * A method to convert given Vaadin sort hints to Spring Data specific sort
 * instructions.
 *
 * @param vaadinSortOrders a list of Vaadin QuerySortOrders to convert to
 * @return the Sort object for Spring Data repositories
 */
public static Sort toSpringDataSort(List<QuerySortOrder> vaadinSortOrders) {
    return Sort.by(
            vaadinSortOrders.stream()
                    .map(so -> 
                            so.getDirection() == SortDirection.ASCENDING ? 
                                    Sort.Order.asc(so.getSorted()) : // <5>
                                    Sort.Order.desc(so.getSorted())
                    )
                    .collect(Collectors.toList())
    );
}
----

<1> If you are using property name based column definition, Grid columns can be made sortable by their property names. The `setSortableColumns` method makes columns with given identifiers sortable and all other non-sortable.
<2> Alternatively, define a key to your columns, which will be passed to the callback, and define the column to be sortable.
<3> In the callback, you need to convert the Vaadin specific sort information to whatever your backend understands. In this example, we are using Spring Data and using a separate method to convert the values. The method body is shown below. Note that the conversion becomes simpler if you only want to support sorting based on a single property. Vaadin Grid supports sorting based on multiple columns.
<4> Here we pass the backend compatible sort information to our backend call.
<5> The `getSorted` method in QuerySortOrder returns the columns property name or a key you have assigned to the column.

=== Filtering a Grid with lazy data binding

Also, filtering needs to happen in the backend in efficient lazy data binding. If you provide, for example, a text field to limit your results in a `Grid`, you need to make your callbacks to take care of the filter.

*Example*: Making a filterable lazy data binding to a Spring Data repository

[source, java]
----
public void initFiltering() {
    filterTextField.setValueChangeMode(ValueChangeMode.LAZY); // <1>
    filterTextField.addValueChangeListener(e -> listPersonsFilteredByName(e.getValue())); // <2>
}

private void listPersonsFilteredByName(String filterString) {
    String likeFilter = "%" + filterString + "%";// <3>
    grid.setItems(q -> repo
        .findByNameLikeIgnoreCase(
            likeFilter, // <4>
            PageRequest.of(q.getPage(), q.getPageSize()))
        .stream());
}
----

<1> The lazy data binding mode is optimal for filtering purposes. Queries to the backend are only done when a user makes a small pause while typing.
<2> When a value change event happens, you should reset the data binding to use the new filter.
<3> The example backend uses SQL behind the scenes, so `%` is appended to the beginning and to the end to match anywhere in the text.
<4> Pass the filter to your backend in the binding.

You can combine both filtering and sorting in your data binding callbacks.

=== Improving scrolling user experience of lazy data binding

In the case of the simple lazy data binding, the component doesn't know how many items there are actually available. When a user scrolls to the end of the scrollable area, the Grid polls your callbacks for more items. If new items are found, those are added to the component. This causes the relative scrollbar to behave in a bit weird day as new items are added on the fly. The usability can be improved by giving an estimate or the actual number of items in the binding code. The adjustment happens via DataView instance, returned by the `setItems` method.

*Example*: Configuring the estimate of rows and how the "virtual row count" is adjusted when the user scrolls down.

[source, java]
----
GridLazyDataView<Person> dataView = grid.setItems(query -> { // <1>
    return getPersonService()
            .fetchPersons(query.getOffset(), query.getLimit())
            .stream();
});

dataView.setItemCountEstimate(1000); // <2>
dataView.setItemCountEstimateIncrease(500); // <3>
----

<1> When assigning the callback, a data view object is returned. It can be configured directly or saved for later adjustments.
<2> If you know a rough estimate or rows, giving that to the component
increases the user experience. Users can, for example, scroll directly to the end of the result set.
<3> You can also configure how `Grid` adjusts its estimate of available rows. With this configuration, if the backend returns an item for index 1000, the scrollbar is adjusted as if there were 1500 items in the `Grid`.

*Example*: Providing a count callback to get similar user experience as when assigning data directly. Note that in many backends, counting the number of results may be a heavy operation.

[source, java]
----
dataView.setItemCountCallback(q -> getPersonService().getPersonCount());
----

== Making a lazy data binding to ComboBox

// TODO change this into data view style once the changes are in ComboBox

The lazy loaded binding in `ComboBox` is always filtered by the string typed in by the end user. If there is not filter yet input, the filter is empty string. `ComboBox` currently uses the old data provider naming convention. Also the count of total matches is currently required.

*Example*: Making a lazy data binding to a Spring Data repository.

[source, java]
----
ComboBox<Person> cb = new ComboBox<>();
cb.setDataProvider((String filter, int offset, int limit) -> {
    return repo.findByNameLikeIgnoreCase(
            "%" + filter + "%", // <1>
            PageRequest.of(offset / limit, limit)
    ).stream();
}, filter -> {
    return (int) repo.countByNameLikeIgnoreCase("%" + filter + "%"); // <2>
});
----

<1> Add `%` marks to filter for SQL like query
<2> The total amount of items matching the filter is required

== Accessing currently set items in the components

In certain cases it is handy get a handle to all items in the component. For example add-ons or generic helpers might want to do something with the data that is currently listed in the component. For such a purposes, the super type of data views can be accessed with `getGenericDataView` method.

CAUTION: Calling certain methods in data views can be an expensive operation. Especially when using a lazy data binding, calling for example `grid.getGenericDataView().getItems()` will cause the whole data set to be loaded from the backend.

*Example*: A generic helper method to export persons listed in a Grid to a CSV file.

[source, java]
----
private void exportToCsvFile(Grid<Person> grid) 
        throws FileNotFoundException, IOException {
    GridDataView<Person> dataView = grid.getGenericDataView(); // <1>
    FileOutputStream fout = new FileOutputStream(new File("/tmp/export.csv"));
    
    dataView.getItems().forEach(person -> {
        try {
            fout.write((person.getFullName() + ", " + person.getEmail() +"\n").getBytes());
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    });
    fout.close();
}
----

If you have assigned your items as in memory data you have more methods available in a list data view object. You can get the reference to that as a return value of `setItems` method or via `getListDataView` method. You can for example get the next or previous item of a certain item. You can do the same naturally by saving the original data structure too, but this way you can implement a generic UI logic without dependencies to the assigned data.

*Example*: An example of programmatically selecting a next item in a Grid, if current value and next item after it exists.
[source, java]
----
List<Person> allPersons = repo.findAll();
GridListDataView<Person> gridDataView = grid.setItems(allPersons);

Button selectNext = new Button("Next", e -> {
    grid.asSingleSelect().getOptionalValue().ifPresent(p -> {
        gridDataView.getNextItem(p).ifPresent(
                next -> grid.select(next)
        );
    });
});
----


== Updating the data loaded into components

A typical scenario in Vaadin apps is that data displayed in, for example, a Grid component, is edited elsewhere in the application. Editing the item elsewhere does not automatically update the UI in a listing component. An easy way to refresh the listing component's content is to call `setItems` method again with fresh data. Alternatively, you can use more fine-grained APIs in the DataView to update just a portion of the dataset.

 *Example*: Modifying a displayed item in a click listener and notifying Grid about the updates to a specific item through the DataView API.

[source, java]
----
Person person = new Person();
person.setName("Jorma");
person.setEmail("old@gmail.com");

GridListDataView<Person> gridDataView = grid.setItems(person);

Button modify = new Button("Modify data", e -> {
    person.setEmail("new@gmail.com");
    // The component shows the old email until notified of changes
    gridDataView.refreshItem(person);
});
----

If you are mutating the data set bound to a component like grid, the databinding must be reset. Alternatively, if you have bound a mutable `List` to your component, you can use helper methods in the list data view to add or remove items or obtain item count by hooking to item count change event or request the item count directly.

*Example*: Using mutation methods and listening to item count change via list data view.

[source, java]
----
ArrayList<String> items = new ArrayList<>(Arrays.asList("foo", "bar"));

Select<String> select = new Select<>();
SelectListDataView<String> dataView = select.setItems(items);

TextField newItemField = new TextField("Add new item");
Button addNewItem = new Button("Add", e-> {
        dataView.addItem(newItemField.getValue());
});
Button remove = new Button("Remove selected", e-> {
        dataView.removeItem(select.getValue());
});

// Hook to item count change event
dataView.addItemCountChangeListener(e ->
        Notification.show(" " + e.getItemCount() + " items available"));

// Request the item count directly
Span itemCountSpan = new Span("Total Item Count: " + dataView.getItemCount());
----

If you are using in-memory data set, you can also apply filters via the data view object. The filtered list is automatically updated to the UI.

*Example*: Using the list data view to filter items based on it's property

[source, java]
----
List<Person> allPersons = repo.findAll();
GridListDataView<Person> gridDataView = grid.setItems(allPersons);

// Filter Persons younger 20 years
gridDataView.setFilter(p -> p.getAge() < 20);
----


== Recycling data binding logic

In large applications there are typically multiple places where same data type is listed. You can use multiple approaches to share the lazy data binding logic.

*Example*: A domain object specific component implementation. This approach allows sharing also other common configuration.

[source, java]
----
@SpringComponent
public class PersonGrid extends Grid<Person> {

    public PersonGrid(@Autowired PersonRepository repo) {
        super(Person.class);
        // Make the lazy binding
        setItems(q -> repo.findAll(
                PageRequest.of(q.getPage(), q.getPageSize())).stream());
        // Make other common/default configuration
        setColumns("name", "email");
    }
    
}
----

*Example*: A static helper method to bind to do the data binding.

[source, java]
----
public static void listItems(Grid<Person> grid, PersonRepository repository) {
    grid.setItems(query -> repository.findAll(
            PageRequest.of(query.getPage(), query.getPageSize())).stream());
}
----

*Example*: Creating a separate data provider class. This example uses only the FetchCallBack, but you and also implement a full data provider by for example extending from AbstractBackEndDataProvider classs.

[source, java]
----
@SpringComponent
public class PersonDataProvider implements CallbackDataProvider.FetchCallback<Person, Void> {
    
    @Autowired
    PersonRepository repo;

    @Override
    public Stream<Person> fetch(Query<Person, Void> query) {
        return repo.findAll(PageRequest.of(query.getPage(), query.getPageSize())).stream();
    }
    
}

personGrid.setItems(dataProvider);

----
