---
title: Embedding a Flow Application
order: 15
layout: page
---

= Embedding a Flow Application

It is possible to embed Vaadin components into non-Vaadin application.
To be able to do this you may use so called server side web components (SSWC).
The web components should be declared in a separate Vaadin application 
using `@WebComponent` annotation.

You will need a `VaadinServlet` which handles requests to your web components. 
This servlet may be declared in the same non-Vaadin application
or may be deployed separately as a standalone WAR file.

You may use various server side Java technologies like JSP, Thymeleaf, servlet or 
just static HTML page to embed Vaadin application. 

We consider the simplest example with a custom servlet which shows primarily
a static content but the content depends on whether a user is logged in.
The whole logic of the application will be handled by one servlet but 
we will implement login form using Vaadin server side web component. The
`VaadinServlet` will be a part of the same application but its mapping 
should differ from the main servlet mapping.

Here is how the main servlet code may look like:

[source, java]
----
@WebServlet(urlPatterns = { "/*" })
public class MainAppServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        Object authToken = req.getSession().getAttribute("auth_token");
        boolean isAuthenticated = authToken != null;

        try (PrintWriter out = response.getWriter()) {
            out.println("<!DOCTYPE html>");
            out.println("<html><head>");
            out.println(
                    "<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>");
            if (!isAuthenticated) {
                out.println(
                        "<link rel='import' href='/vaadin/web-component/login-form.html'>");
            }
            out.println("<body>");
            if (isAuthenticated) {
                out.println("<h1>Welcome "
                        + UserService.getInstance().getName(authToken)
                        + "</h1>");
            } else {
                out.println(
                        "<login-form userlbl='Username' pwdlbl='Password'></login-form>");
            }
            out.println("</body>");
            out.println("</html>");
        }
    }
}
----

We are using `UserService` class which is shared between the `MainAppServlet` and 
the web component class. It contains authentication logic and may have any interface
and implementation which you want. Here is its interface and custom stub implementation 
just for a reference:
    
[source, java]
----
public final class UserService {

    private static final UserService INSTANCE = new UserService();
    
    private UserService(){
    }

    public static UserService getInstance() {
        return INSTANCE;
    }

    public String getName(Object authToken) {
        return "Joe";
    }

    public Optional<Object> authenticate(String user, String passwd) {
        if ("admin".equals(user) && "admin".equals(passwd)) {
            return Optional.of(new Object());
        } else {
            return Optional.empty();
        }
    }
}
----

The HTML content generated by the servlet is quite simple. There are 
two important lines which requires our attention. The first line is the import of our web component:

[source, html]
----
<link rel='import' href='/vaadin/web-component/login-form.html'>
----

The link URI starts with `/vaadin/`. This is the URI which we are going to 
map our Vaddin servlet (see below). The second part is `/web-component/login-form.html`.
This is standard URI which you should use to address your server side web component.
It consists of hardcoded `web-component` part and following `login-form.html` 
web component file part. The web component file will be generated for you 
by the Vaadin application based on its name. In this specific case the name
of your web component has to be `"login-form"`. This name you should use
in the `@WebComponent` annotation and in your HTML code where you want
to put this web component. In our example this is done right in the `body` tag:

[source, html]
----
<login-form userlbl='Username' pwdlbl='Password'></login-form>
----

The web component has two properties (`userlbl` and `pwdlbl`) whose values we pass from the HTML to a
web component instance.

Here is the `VaadinServlet` registration:

[source, java]
----
@WebServlet(urlPatterns = {"/vaadin/*", "/frontend/*" })
public class WebComponentVaadinServlet extends VaadinServlet {
}
----

As mentioned above `/vaadin/*` mapping is used for `VaadinServlet` to handle 
web component requests (it can be any URI but make sure you use the same URI in the mapping
and in the import declaration). We use `/frontend/*` mapping for the servlet as well because 
we want to handle webjar resources URI since we are using various Vaadin components
in our server side web component code which requires `frontend` URI handler.

Finally here is the web component code:

[source, java]
----
@WebComponent("login-form")
public class LoginForm extends Div {

    private WebComponentProperty<String> userlbl = new WebComponentProperty<>(
            "", String.class);

    private WebComponentProperty<String> pwdlbl = new WebComponentProperty<>("",
            String.class);

    private TextField userName = new TextField();
    private PasswordField password = new PasswordField();
    private Div errorMsg = new Div();

    public LoginForm() {
        FormLayout layout = new FormLayout();

        updateForm(layout);

        userlbl.addValueChangeListener(event -> updateForm(layout));
        pwdlbl.addValueChangeListener(event -> updateForm(layout));

        add(layout);

        Button login = new Button("Login", event -> login());
        add(login, errorMsg);
    }

    private void updateForm(FormLayout layout) {
        layout.removeAll();

        layout.addFormItem(userName, userlbl.get());
        layout.addFormItem(password, pwdlbl.get());
    }

    private void login() {
        Optional<Object> authToken = UserService.getInstance()
                .authenticate(userName.getValue(), password.getValue());
        if (authToken.isPresent()) {
            VaadinRequest.getCurrent().getWrappedSession()
                    .setAttribute("auth_token", authToken.get());
            getUI().get().getPage()
                    .executeJavaScript("window.location.href='/'");
        } else {
            errorMsg.setText("Authentication failure");
        }
    }

}
----

As you can see the web component class is mapped to the `login-form` tag 
via the `@WebComponent("login-form")` annotation. All such annotation declarations are
scanned at startup and Polymer web component HTML file is generated for every 
server side web component (this file you import in the `head`).

The component implementation uses several Vaadin components: `FormLayout`, `TextField`,
`PasswordField` and `Button`. `WebComponentProperty` field declaration is used 
to receive values from the HTML element to the web component instance. In this example
we have declared the labels for user name field and password field via HTML instead 
of hardcoding them in the Java class.

There is one more way to send values from HTML to the web component instance.
You may declare a method in your class and annotate it with `@WebComponentMethod("message")` 
where `"message"` is the HTML property name. Here is an example:

[source, java]
----
@WebComponentMethod("message")
public void setMessage(String message) {
    msg.setText(message);
}
----

The method is called whenever the property value is changed. It's useful
when you don't need to track the value but just need to do some action
if it's changed.

In this example the authentication is done inside the web component code 
and an authentication token is set to the `HttpSession` which makes it available
while the session is alive. And since the main application servlet uses the 
same `HttpSession` instance it now changes its behavior. Once the user is
authenticated we redirect to the main servlet which now shows the content
specific for the authenticated user.
