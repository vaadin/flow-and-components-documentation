---
title: Introduction to Vaadin Flow
order: 1
layout: page
---
= Introduction to Vaadin Flow

Vaadin Flow connects the Java ecosystem to your web platform. Flow is an integral part of the Vaadin platform.  

In this section we provide an overview of the Vaadin Flow architecture and introduce basic Flow concepts.

== Vaadin Flow Architecture

Working with front end web technologies, such as HTML, CSS and JavaScript, can be challenging and time-consuming for Java developers. In Vaadin Flow, all user interface elements are componentized into https://www.webcomponents.org/[Web Components]. This makes development easier than ever before because each element is decoupled and sandboxed. 

Vaadin Flow includes:

* A type-safe Java UI Component API on the server side that facilitates use of the Web Components. 

* Automated bi-directional communication between the server and the browser, that:

** Gives Java developers full access to all modern web enhancements. 
** Makes it easier to connect the UI to data via a robust Java backend, instead of using traditional REST-based communication. 

* Two-way data binding: when the UI is changed on either the client or the server, the changes are automatically reflected on the other side.


image:images/v10-architecture.png[Vaadin 10 Architecture,1200,430]

Flow allows you to access browser APIs, Web Components, and even simple DOM elements, directly from the server-side Java. It is not necessary to understand how the client-to-server communication or Web Components work. This leaves you free to focus on creating components that work at a higher-abstraction level. 

image:images/dom-to-java.png[dom-to-java,500,432]

== Building UIs with Components

UI components that are designed to build interactive web apps are the core of Vaadin Flow. 
In addition, Flow provides powerful abstraction layers that you can use to create new components.

=== Vaadin Components

The high abstraction layers provided by Flow's Java Web Components API allow you to build UIs in an extremely productive way. You do not need any HTML or JavaScript knowledge, and only enough CSS experience to style the look and feel of your app. 

[source,java]
----
TextField textField = new TextField();
Span greeting = new Span("Hello stranger"); // a simple html inline text

textField.addValueChangeListener(event ->
      greeting.setText("Hello " + event.getValue()));

VerticalLayout layout = new VerticalLayout(textField, greeting);
----

The API includes prebuilt server-side components for Vaadin components and most native HTML elements. 

See <<../components/tutorial-flow-components-setup#,Using Vaadin Components>> for a full set of available Vaadin components. 

=== Composing new Components in 100% Java

On the higher abstraction layers, you can easily create custom components by adapting or combining existing components to meet your requirements. 

The light-weight component architecture and the ability to access the DOM and browser APIs from the server side, simplifies component customization. While staying on the server side you can  perfect customizations and eliminate bugs, by leveraging Flowâ€™s automated communication layer between the browser and the server. 

[source,java]
----
@Tag("my-label")
public class MyLabel extends Component {
    public void setText(String text) {
        getElement().setText(text);
    }

    public String getText() {
        return getElement().getText();
    }
}
----

See the tutorials in <<../creating-components/tutorial-component-basic#,Creating Components>> to learn how to build components with a reusable API, and <<../element-api/tutorial-event-listener#,Element API>> to learn how to access and customize the DOM from the server side.


=== Integrating a Web Component

Flow allows you to create a Java API for any available Web Component and then use the API in your projects.

[source,java]
----
@Tag("game-card")
@HtmlImport("bower_components/game-card/game-card.html")
public class GameCard extends Component {

}
----

See the tutorials in <<../web-components/integrating-a-web-component#,Integrating a Web Component>> for more.

You can also find prebuilt Java APIs for Web Components that have been published by the Vaadin Community in the https://vaadin.com/directory/search?framework=Vaadin%2010[Vaadin Directory.]


=== Building Components with HTML Templates

Another way to create components is by separating layout and ui logic. This is done best by using HTML templates together with Java classes, where the HTML file contains the layout and (if needed) pure client side logic, while the Java class takes care of the server side logic, like event handling. You may then use your component as any other component in your Java environment - Flow does not distinguish between pure Java or HTML/Java combined components.
 
*Example*: @Id injection in a component
[source,html]
----
<template>
    <vaadin-vertical-layout>
        <vaadin-text-field id="textField"></vaadin-text-field>
        <label id="greeting">Hello stranger</label>

        <input type="color" on-input="updateFavoriteColor">
        <label>Favorite color: </label>
    </vaadin-vertical-layout>
</template>
----

[source,java]
----
private @Id("textField") TextField textField;
private @Id("greeting") Label greeting;

// Setting things up in the component's constructor
textField.addValueChangeListener(event ->
      greeting.setText("Hello " + event.getValue()));

// Instance method in the component published to the client
@EventHandler private void updateFavoriteColor(
      @EventData("event.target.value") String color) {
    getModel().setColorCode(color);
}
----

See the tutorials in <<../polymer-templates/tutorial-template-basic#,Creating Polymer Templates>> for more.


== Routing and Navigation

Flow provides the `Router` class to structure the navigation of your web application or site into logical parts.

Use the `@Route` annotation to register navigation targets. You can specify a path, and optionally a parent layout class, in which to display the component. 


[source,java]
----
// register the component to url/company and show it inside the main layout
@Route(value="company", layout=MainLayout.class)
@Tag("div")
public class CompanyComponent extends Component {
}

public class MainLayout extends Div implements RouterLayout {
}
----

See the tutorials in <<../routing/tutorial-routing-annotation#,Routing and Navigation>> for more.


== How Flow Components Work

Flow allows Java code to control the DOM in the web browser with a server-side Java representation of the same DOM tree.
All changes are automatically synchronized to the real DOM tree in the browser.

The DOM tree is built up from `Element` instances: each instance represents a DOM element in the browser.
The root of the server-side DOM tree is the `Element` of the `UI` instance. You can access it using the `ui.getElement()` method.
This element represents the `<body>` tag.

Elements on the server are implemented as flyweight instances.
This means that you cannot compare elements using the `==` and `!=` operators.
Instead, you use the `element.equals(otherElement)` method to check whether two instances refer to the same DOM element in the browser.

=== Element Hierarchy

A web application is structured as a tree of elements, with the `UI` instance element as the root.
An element can be added as a child of another element, using methods such as:

* `element.appendChild(Element)` to add an element at the end of a parent's child list, or 
* `element.insertChild(int, Element)` to add it to any position in the child list.

Use `element.getParent()` to navigate upwards in the element hierarchy, and `element.getChildCount()` to navigate downwards. 


=== Component Hierarchy

The `Component` class wraps the `Element` and provides a higher level of abstraction. You can obtain the element representation of a component using the `Component.getElement()` method.

The component's element can optionally contain any number of child elements. In addition to the low level element, the component itself may also support child components. In that case it provides likewise methods like `Component.add(Component... )`. 

As with elements you may navigate through component's hierarchy: use `component.getParent()` to navigate upwards in the component hierarchy, and `component.getChildren()` to navigate downwards.

The component hierarchy is constructed based on the element hierarchy. Changes in the component's hierarchy are reflected in the element's hierarchy (but not vice versa).


=== HTML Templates

As an alternative to creating the DOM in Java, you can use HTML templates. In this case, Java is only used for server-side control and interaction with elements, for example via event listeners.

Possible benefits of this approach include:

* A clearer overview of the structure of the component.
* Improved performance: The same template definition is used for all component instances using the same template file. This means that less memory is used on the server and less data needs to be sent to the browser.

*NEXT*: *<<tutorial-get-started-first-part#,Part 1 - Getting Started with Vaadin Flow>>* 
