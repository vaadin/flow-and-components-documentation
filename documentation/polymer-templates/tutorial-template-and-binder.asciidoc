---
title: How to combine templates with binders
order: 11
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]
= How to combine templates with binders

Combining templates with binders is a necessary aspect in every Vaadin application.
Templates are the recommended way of building UIs and binders are the recommended way of building forms.

This process is almost the same as using binders with declared components.

The first step is to declare an HTML template.

.user-form HTML Template
[source,html]
----
<dom-module id="user-form">
    <template>
        <style>
        ...
        </style>
        <vaadin-form-layout id="form">
            <vaadin-text-field id="email" label="Email (login)" colspan="2"></vaadin-text-field>
            <vaadin-text-field id="first-name" label="First Name"></vaadin-text-field>
            <vaadin-text-field id="last-name" label="Last Name"></vaadin-text-field>
            <vaadin-text-area id="comments" label="Comments"></vaadin-text-area>
        </vaadin-form-layout>
        <form-buttons-bar id="action-buttons"></form-buttons-bar>
    </template>
    ...
</dom-module>
----

And the server side template as:

.UserForm.class
[source,java]
----
@Tag("user-form")
@HtmlImport("src/user-form.html")
public class UserForm extends PolymerTemplate < UserForm.FormComponentModel > {

  @Id("email")
  private TextField email;

  @Id("first-name")
  private TextField firstName;

  @Id("last-name")
  private TextField lastName;

  @Id("comments")
  private TextArea comment;

  @Id("action-buttons")
  private FormButtonsBar actionButtons;
----

Once the mapping between Java and the HTML template is done, the process of binding can start.

- The first step is to declare a binder as a class variable in the UserForm.class:
[source,java]
----
private Binder<User> binder;
----

- After that, we can create a method that initializes the binder and links it with the form’s fields:
[source,java]
----
private void initBinder() {
    binder = new Binder<>();

    // email textField
    binder.forField(email).withValidator(
            new EmailValidator("This doesn't look like a valid email address")
    ).bind(User::getEmail, User::setEmail);

    // firstName textField
    binder.forField(firstName).withValidator(firstName -> firstName.length() > 1,
            "The first name must contains at least 2 characters").asRequired()
            .bind(User::getFirstName, User::setFirstName);

    // lastName textField
    binder.forField(lastName).asRequired("It can not be empty")
            .bind(User::getLastName, User::setLastName);

    // comment textArea
    binder.forField(comment).asRequired("It can not be empty")
            .bind(User::getComment, User::setComment);
}
----

[NOTE]
For more information refer to <<tutorial-flow-components-binder#,Binding Data to Forms>>

- We can call initBinder inside the constructor of the class:
[source,java]
----
public UserForm() {
    initBinder();
}
----

Once the binding process is working we can declare methods in the *UserForm.java*
that allows to set and get a user object in the form:

.UserForm.class
[source,java]
----
/**
 * Connects the bean to the binder.
 *
 * @param user bean
 */
public void setBean(User user) {
    binder.setBean(user);
}

/**
 * Clears the form and disconnnect any bean.
 */
public void removeBean() {
    binder.removeBean();
}

/**
 * Gets the bean(user) from the binder.
 *
 * @return
 */
public Optional<User> getBean() {
    return Optional.of(binder.getBean());
}
----

Now the UserForm component is ready to be used in other parts of our code.

== Main view
The MainView is a template that contains a grid of users and the user-form component of previous steps:

.main-view HTML Template
[source,html]
----
<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="user-form.html">
<link rel="import" href="../bower_components/vaadin-grid/src/vaadin-grid.html">

<dom-module id="main-view">
    <template>
        <style>
            ...
        </style>
        <div id="main-container">
            <vaadin-grid id="users-grid"></vaadin-grid>
            <user-form id="user-form"></user-form>
        </div>
    </template>
    ...
</dom-module>
----

.MainView.class
[source,java]
----
@Tag("main-view")
@HtmlImport("src/main-view.html")
@Route("")
public class MainView extends PolymerTemplate<TemplateModel> {

    @Id("user-form")
    private UserForm userForm;

    @Id("users-grid")
    private UsersGrid usersGrid;

    ...
}
----


The result is the following:

image:images/template-and-binder-first-result.png[MainView]

Now the objective is to configure it, in a way that when a row is clicked the form is filled with the information of that user.

To achieve it, a row selection listener must be declared, as well as a listener for the buttons of the form:

.MainView.class
[source,java]
----
/**
 * Initializes the Main view and the listeners of its components.
 */
public MainView() {

    // selection listener on the rows of the grid.
    usersGrid.addSelectionListener(selectionEvent -> {
        Optional<User> optionalUser = usersGrid.getSelectedItems().stream().findAny();

        if (optionalUser.isPresent()) {
            userForm.setBean(optionalUser.get());
            setEditionEnabled(true);
        } else {
            userForm.removeBean();
            setEditionEnabled(false);
        }
    });

    initFormListeners();
}
----

In the initFormListener, the listeners for the buttons SAVE, CANCEL and DELETE need to be implemented:

=== Save

In the `save` listener, the state of the bean is checked. If it is correct,
a user object is generated from the userForm.
The user is saved calling a method of the repository and that item of the grid is refreshed, showing the modifications.

.MainView.class - initFormListeners
[source,java]
----
formButtonsBar.addSaveListener(saveEvent -> {
    // it checks that the bind user of the UserForm has a correct format.
    if (!userForm.getBinder().validate().isOk()) {
        return;
    }

    Optional<User> optionalUser = userForm.getBean();

    if (optionalUser.isPresent()) {
        User user= optionalUser.get();

        user = userUsersRepository.save(user);

        usersGrid.refresh(user);
        userForm.setBean(user); // in case that the Repository is a DB
    }
});
----

=== Cancel

In the `cancel` listener all the elements of the grid are deselected and the form is emptied.

.MainView.class - initFormListeners
[source,java]
----
formButtonsBar.addCancelListener(cancelEvent -> {
    usersGrid.deselectAll();
});
----
Notice that the deselection of the grid’s row triggers an event that will remove the bean.
See `usersGrid.addSelectionListener` implementation.

=== Delete

The selected user is selected from the grid and the user is removed calling `UsersRepository.delete`
and the user(bean) is removed from the UserForm. When a user(bean) is removed, the fields of the UserForm are empty.

.MainView.class - initFormListeners
[source,java]
----
formButtonsBar.addDeleteListener(deleteEvent -> {
    Optional<User> optionalUser = usersGrid.getSelectedItems().stream().findAny();

    if (optionalUser.isPresent()) {
        UsersRepository.delete(optionalUser.get());
        usersGrid.refreshAll();
        userForm.removeBean();
        usersGrid.deselectAll();
    }
});
----


== Result

When a row is selected, the form is filled with the information of that user.
If the save button is clicked the modifications of a user will be saved, and when
the delete button is clicked the user is deleted from the form and grid.

image:images/template-and-binder-second-result.png[MainView]