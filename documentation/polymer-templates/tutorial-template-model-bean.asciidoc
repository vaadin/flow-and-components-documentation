---
title: Using Beans with a PolymerTemplate Model
order: 8
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]
= Using Beans with a PolymerTemplate Model

Using beans is a simple way to define a Polymer template model. You can also reuse existing beans in your model. Any bean that has a public no-arg constructor is suitable for a template model.

A typical use case is a form with editable contents for one or more entities.

*Example*: Polymer template form with editable `Person` fields.

[source,js]
----
class MyForm extends PolymerElement {
    static get template() {
        return html`
            <div>
                <div>
                    <span>First name</span>
                    <input value="[[person.firstName]]" />
                </div>
                <div>
                    <span>Last name</span>
                    <input value="[[person.lastName]]" />
                </div>
                <div>
                    <span>Age</span>
                    <input value="[[person.age]]" />
                </div>
            </div>
            <div>
                <button on-click="setNameToJeff">Set Name To Jeff</button>
            </div>
        `;
    }

    static get is() {
        return 'my-form'
    }
}

customElements.define(MyForm.is, MyForm);
----

*Example*: `Person` bean definition.
[source,java]
----
public class Person {
    private String firstName, lastName;
    private int age;
    private Long id;

    public Person() {
        // Needed for TemplateModel
    }

    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public int getAge() {
        return age;
    }

    public Long getId() {
        return id;
    }
}
----

== Defining the Bean to Use

You can specify that your model use a specific bean, by adding a setter and a getter for it.

*Example*: Defining a setter and getter for the `Person` bean in the template model.

[source,java]
----
public interface FormModel extends TemplateModel {
  @Exclude("id")
  void setPerson(Person person);
  Person getPerson();
}
----
* You can use the `@Include` annotation and provide a list of properties to be imported (all other properties are excluded), as an alternative to the `@Exclude` annotation. In this example, `@Include({"firstName","lastName","age"})` has the same effect as the `@Exclude("id")` annotation.

[TIP]
You can include and exclude sub bean properties using the dot notation, for example `@Exclude("account.password")`.

It is not necessary to declare the `Person` type as a class: you can declare it as an interface. There is also no need to create its instance and use a setter. Simply call `getPerson()` and the model will return an empty proxy object that you can use to set its property directly.

[NOTE]
When setting backend data directly to the model, you must exclude any bean properties that lead to circular dependencies. For example, if a `Patient` bean has a `Doctor doctor` property, the `Doctor` bean should not have a property with the type `Patient` (or as a generic type for a collection property), as this leads to a circular dependency.


== Initializing a Template Model

You can initialize the model in the template by setting a new `person` instance for it.

*Example*: Setting a new `person` instance in the `Form` template class.

[source,java]
----
public class Form extends PolymerTemplate<FormModel> {
    public Form() {
        Person person = new Person("John", "Doe", 82);
        getModel().setPerson(person);
    }
}
----
* If you later update the `Person person` bean created in the constructor, the model will remain unchanged. The bean is not attached to the model in any way. The bean values are copied by the `setPerson` method.

== Updating the Template Model

To update the values in the model, you can use the `getModel().getPerson()` method, or the `getModel().getProxy("person", Person.class)` method. The latter gets a proxy `Person` object that is attached to the model. Any changes you make to the proxy object automatically update the model.

*Example*: Defining an event handler for a `nameChange` in the `Form` template class.

[source,java]
----
public class Form extends PolymerTemplate<FormModel> {
    @EventHandler
    public void setNameToJeff() {
        getModel().getPerson().setFirstName("Jeff");
    }
}
----

[NOTE]
The proxy bean returned by the getter is not meant to be passed to an `EntityManager` or similar. Its only purpose is to update the values in the model.

[NOTE]
The bean is never stored as a bean in the model. Instead, the individual parts of the bean are stored. No method will ever return the original bean.

[WARNING]
There is currently no way to get a detached bean from the model.

== Using Model Data with an Entity Manager

When using model data with an entity manager, you need to re-instantiate a new entity and set the values using the getters for the item retrieved from the model.

*Example*: Using model data with the `OrderService` service.

[source,java]
----
public class OrderForm extends PolymerTemplate<FormModel> {

    public interface FormModel extends TemplateModel {
      @Exclude("id")
      void setPerson(Person person);
      Person getPerson();
    }

    public OrderForm() {
        Person person = new Person("John", "Doe", 82);
        getModel().setPerson(person);
    }

    @EventHandler
    public void submit() {
        Person person = getModel().getPerson();
        getService().placeOrder(new Person(person.getFirstName(), person.getLastName(), person.getAge()));
    }

    private OrderService getService() {
        // Implementation omitted
        return new OrderService();
    }
}
----
* In this example, we cannot send the `Person` object from the model directly to the service, because the object is proxied and only returns data when the getters are used.

== Excluding Long Properties Types

Vaadin Flow does not support the `Long` property type and this type cannot be mapped correctly to any client types. Any properties with the type `Long` need to be excluded. You can use the `@Exclude` or `Include` annotations to do this.

You can also use the `@Encode` annotation to encode a `Long` value to a `String` value, where appropriate. See <<tutorial-template-model-encoders#,Using Model Encoders with a PolymerTemplate Model>> for more.

See the following related resources for more:

* <<tutorial-template-basic#,Creating A Simple Component Using the PolymerTemplate API>>.

* <<tutorial-template-bindings#,Binding Model Data in a PolymerTemplate>>.
