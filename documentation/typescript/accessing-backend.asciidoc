---
title: Accessing Java Backend in TypeScript
order: 60
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]

= Accessing Java Backend in TypeScript

An API endpoint is a backend method that is exposed for calling from client-side
TypeScript code.

Vaadin endpoint is a class that defines one or more API methods.

Vaadin bridges Java backend endpoints and a TypeScript frontend. It generates
TypeScript clients to call the Java backend in a type-checkable way.

[WARNING]
This feature is experimental and it *will change* before the next Long-Term-Supported Vaadin version.
If you have an idea how to make it more useful for you, please share it on link:https://github.com/vaadin/flow/issues/new/[GitHub^].

== How to create a Vaadin endpoint? [[how-to-create-vaadin-endpoint]]

Annotate any existing class with the `@Endpoint` annotation or create such
class from scratch:

[source,java]
----
import com.vaadin.flow.server.connect.Endpoint;

/**
 * A Vaadin endpoint that counts numbers.
 */
@Endpoint
public class CounterEndpoint {
    /**
     * A method that adds one to the argument.
     */
    public int addOne(int number) {
        return number + 1;
    }
}
----

After that, when the application starts, Vaadin analyzes such classes in order
to be able to process the requests made to such endpoints, and to appropriately
verify user access. Please refer to the <<configuring-security#, Security page>>
for configuring endpoint access.

== TypeScript module

Project has several TypeScript files, variables, functions, classes etc. in a file will be accessible from other files.
Hence, having everything in the global scope can lead to conflicts and errors in the code.

Fortunately, TypeScript has the option of using modules to group related variables, functions, classes and interfaces, in order to be
run in its own scope instead of in the global one. In short, all things declared in a module are not accessible outside the module.

Using the keyword `export` when declaring a module, it is possible to use that module from another file by using the statement `import`.

The following example demonstrates how to create modules:
.City.ts
[source,typescript]
----
// define an interface and export it as a module
export default interface City {
  name: string;
  country: string;
}
----

.index.ts
[source,typescript]
----
// import and use the exported module
import {City} from './City';
const cityObject = new City("Turku", "Finland");
----

== Import and use TypeScript modules generated from Vaadin Endpoint

There is a generated TypeScript module for every Vaadin endpoint on the backend.
Each module exports all the methods.

You can either import the whole generated module as an endpoint, or import the
methods from the module separately. For instance, the
`CounterEndpoint.ts` could be used as in the following snippets:

.index.ts (import the whole module)
[[index.ts]]
[source,typescript]
----
// Other imports
import * as counterEndpoint from './generated/CounterEndpoint';

// Other code
counterEndpoint.addOne(1).then(result => console.log(result));
----

.index.ts (only import the needed method)
[source,typescript]
----
// Other imports
import {addOne} from './generated/CounterEndpoint';

// Other code
addOne(1).then(result => console.log(result));
----

== TypeScript generation details

The generation is done automatically when the application compiles, and when
the application is running in development mode.

By default, the generated files are located under `{project
directory}/frontend/generated`. You can change the folder by providing the path
for the generator in the `generatedFrontendDirectory` property for Vaadin Maven
plugin.

== Example generated TypeScript module contents

For example, the generated TypeScript module for the Java endpoint defined in
 <<accessing-backend#how-to-create-vaadin-endpoint,CounterEndpoint.java>> would look like:

[source,typescript]
.CounterEndpoint.ts
----
/**
 * A Vaadin endpoint that counts numbers.
 *
 * This module has been generated from CounterEndpoint.java
 * @module CounterEndpoint
 */

import client from './connect-client.default';

/**
 * A method that adds one to the argument.
 *
 * @param number
 */
export function addOne(number: number): Promise<number> {
  return client.call('CounterEndpoint', 'addOne', {number}, {requireCredentials: true});
}
----

== Code-completion

As you see in `CounterEndpoint.ts`, the Javadoc of `@Endpoint` class
is preserved the generated TypeScript file, and the type definitions are
maintained. This helps code-completion work pretty well in *Visual Studio Code*
and *Intellij IDEA Ultimate Edition*.

.Code-completion in Visual Studio Code
image:codecompletion.gif[Code-completion]
