---
title: Embedding a Vaadin Application
order: 6
layout: page
---

= Embedding a Vaadin Application

It is possible to embed Vaadin components onto web pages created with
non-Vaadin technologies or even other Vaadin pages.
To be able to do this you may use web component exporter. The exporter
should be declared in a separate Vaadin application.

You will need a `VaadinServlet` which handles requests to your web components.
This servlet may be declared in the same non-Vaadin application
or may be deployed separately as a standalone WAR file.

You may use various server side Java technologies like JSP, Thymeleaf, servlet or
just static HTML page to embed Vaadin application.

We consider the simplest example with a custom servlet which shows primarily
a static content but the content depends on whether a user is logged in.
The whole logic of the application will be handled by one servlet but
we will implement login form using Vaadin server side web component. The
`VaadinServlet` will be a part of the same application but its mapping
should differ from the main servlet mapping.

Here is how the main servlet code may look like:

[source, java]
----
@WebServlet(urlPatterns = { "/*" })
public class MainAppServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req,
            HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType(
                "text/html;charset=UTF-8");

        Object authToken = req.getSession()
                .getAttribute("auth_token");
        boolean isAuthenticated = authToken != null;

        try (PrintWriter out = response.getWriter()) {
            out.println("<!DOCTYPE html>");
            out.println("<html><head>");
            out.println(
                    "<meta http-equiv='Content-Type' "
                    + "content='text/html; "
                    + "charset=UTF-8'>");
            out.println(
                    "<script type='text/javascript' "
                    + "src='log-in.js'></script>");
            if (!isAuthenticated) {
                out.println(
                        "<script type='text/javascript' "
                        + "src='vaadin/VAADIN/build/webcomponentsjs/"
                        + "webcomponents-loader.js'></script>");
                out.println(
                        "<script type='module' src="
                        + "'/vaadin/web-component/"
                        + "login-form.js'></script>");
            }
            out.println("<body>");
            if (isAuthenticated) {
                out.println("<h1>Welcome "
                        + UserService.getInstance()
                              .getName(authToken)
                        + "</h1>");
            } else {
                out.println(
                      "<login-form userlbl='Username' "
                      + "pwdlbl='Password'>"
                      + "</login-form>");
            }
            out.println("</body>");
            out.println("</html>");
        }
    }
}
----

We are using `UserService` class which is shared between the `MainAppServlet`
and the web component class. It contains authentication logic and may have
any interface and implementation which you want. Here is its interface and
custom stub implementation just for a reference:

[source, java]
----
public final class UserService {

    private static final UserService INSTANCE =
            new UserService();

    private UserService(){
    }

    public static UserService getInstance() {
        return INSTANCE;
    }

    public String getName(Object authToken) {
        return "Joe";
    }

    public Optional<Object> authenticate(String user,
            String passwd) {
        if ("admin".equals(user) &&
                "admin".equals(passwd)) {
            return Optional.of(new Object());
        } else {
            return Optional.empty();
        }
    }
}
----

The HTML content generated by the servlet is quite simple. There are
two important lines which requires our attention. The first lines are the
polyfill and script which loads our web component:

[source, html]
----
<script type='text/javascript'
        src='vaadin/VAADIN/build/webcomponentsjs/webcomponents-loader.js'>
</script>
<script type='module'
        src='/vaadin/web-component/login-form.js'>
</script>
----
The first script is the polyfill which enables web components for browsers
which do not offer native support. For example, Chrome and Firefox do not
need to polyfill, while Edge does. The polyfill is loaded from the Vaadin
application.

Next script loads the web component. The link URI starts with `/vaadin/`. This
is the URI which we are going to map our Vaadin servlet (see below). The second
part is `/web-component/login-form.js`.
This is standard URI which you should use to address your web component.
It consists of hard-coded `web-component` part and following `login-form.js`
web component file part. The web component file will be generated for you
by Vaadin based on the exporter's configuration. In this specific case the name
of your web component has to be `"login-form"`. This name you should use
in the exporter's `super` constructor (see `WebComponentExporter` code
example below) and in your HTML code where you want to put this web component.
In our example this is done right under `<body>`:

[source, html]
----
<login-form userlbl='Username' pwdlbl='Password'>
</login-form>
----

The web component has two properties (`userlbl` and `pwdlbl`) whose values we
pass from the HTML to a web component instance.

Here is the `VaadinServlet` registration:

[source, java]
----
@WebServlet(urlPatterns = {"/vaadin/*", "/frontend/*" })
public class WebComponentVaadinServlet
        extends VaadinServlet {
}
----

[NOTE]
If you are going to deploy your web component exporter(s) as a stand-alone
WAR application then you don't need explicit servlet registration shown above.
A servlet instance will be registered for you automatically with the `"/*"` mapping.

As mentioned above `/vaadin/\*` mapping is used for `VaadinServlet` to handle
web component requests (it can be any URI but make sure you use the same URI
in the mapping and in the import declaration). We use `/frontend/*` mapping
for the servlet as well because we want to handle webjar resources URI since
we are using various Vaadin components in our server side web component code
which requires `frontend` URI handler.

Here is the web component class:

[source, java]
----
public class LoginForm extends Div {
    private TextField userName = new TextField();
    private PasswordField password =
            new PasswordField();
    private Div errorMsg = new Div();
    private String userLabel;
    private String pwdLabel;
    private FormLayout layout = new FormLayout();
    private List<SerializableRunnable> loginListeners =
            new CopyOnWriteArrayList<>();

    public LoginForm() {
        updateForm();

        add(layout);

        Button login = new Button("Login",
                event -> login());
        add(login, errorMsg);
    }

    public void setUserNameLabel(
            String userNameLabelString) {
        userLabel = userNameLabelString;
        updateForm();
    }

    public void setPasswordLabel(String pwd) {
        pwdLabel = pwd;
        updateForm();
    }

    public void updateForm() {
        layout.removeAll();

        layout.addFormItem(userName, userLabel);
        layout.addFormItem(password, pwdLabel);
    }

    public void addLoginListener(
            SerializableRunnable loginListener) {
        loginListeners.add(loginListener);
    }

    private void login() {
        Optional<Object> authToken = UserService
                .getInstance()
                .authenticate(userName.getValue(),
                    password.getValue());
        if (authToken.isPresent()) {
            VaadinRequest.getCurrent()
                    .getWrappedSession()
                    .setAttribute("auth_token",
                            authToken.get());
            fireLoginEvent();
        } else {
            errorMsg.setText("Authentication failure");
        }
    }

    private void fireLoginEvent() {
        loginListeners.forEach(
                SerializableRunnable::run);
    }
}
----

In this example, the implementation uses several Vaadin components:
`FormLayout`, `TextField`, `PasswordField` and `Button`. The authentication
is done inside the web component code and an authentication token is set to
the `HttpSession` which makes it available while the session is alive. Since
the main application servlet uses the same `HttpSession` instance it now
changes its behavior. Once the user is authenticated we redirect to the main
servlet which now shows the content specific for the authenticated user.

There are various ways to do this:

- we may execute JS directly from Java code and set location to `"/"` : `getUI().get().getPage().executeJs("window.location.href='/'");`
- design the component code so that its logic is isolated and doesn't need to
know anything about the embedding context.

The second way allows to completely decouple the embedded component logic from
the application which uses it. This way is shown in this example:
the `addLoginListener` method allows to register a listener which is called
in the `fireLoginEvent` method.

Finally, it is the step to export the `LoginForm` component as an embeddable web
component using web component exporter:

[source, java]
----
public class LoginFormExporter
        extends WebComponentExporter<LoginForm> {
    public LoginFormExporter() {
        super("login-form");
        addProperty("userlbl", "")
                .onChange(LoginForm::setUserNameLabel);
        addProperty("pwdlbl", "")
                .onChange(LoginForm::setPasswordLabel);
    }

    @Override
    protected void configureInstance(
            WebComponent<LoginForm> webComponent,
            LoginForm form) {
        form.addLoginListener(() ->
                webComponent.fireEvent("logged-in"));
    }
}
----

The exporter defines its tag name as "login-form" by calling the super
constructor `super("login-form");`. Method `addProperty` is used to define the
component properties, `userlbl='Username' pwdlbl='Password'`, to receive
values from the HTML element to the web component instance. In this example
we have declared the labels for user name field and password field via HTML
instead of hard-coding them in the `LoginForm` component class.

`LoginFormExporter` class implements abstract method `configureInstance` which
registers a login listener. The login listener fires a client-side `"logged-in"`
event using `webcomponent.fireEvent()`. This event should be handled somehow by
the main application.

The custom event is handled by the JS file declared via the line
`<script type='text/javascript' src='log-in.js'></script>`. Here is the
`log-in.js` file content:

[source, html]
----
var editor = document.querySelector("login-form");
editor.addEventListener("logged-in", function(event) {
    window.location.href='/';
});
----

The embedding servlet uses "API" provided by the `LoginForm` via a custom event
and adds an event listener for the event. The listener just redirects the page to
the `"/"`  location.
