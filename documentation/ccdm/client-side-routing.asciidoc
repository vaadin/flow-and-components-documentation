---
title: Client-side Routing
order: 2
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]

= Client-side Routing

Client-side routing adds the ability to combine regular Flow <<../routing/tutorial-routing-annotation#,views in Java>> (server-side views) and client-side views in JavaScript or TypeScript.

It lets you to use link:https://vaadin.com/router[Vaadin Router] to define routes in your `index.js` or `index.ts` file, and delegate server-side Flow routes when no client-side routes matches.

The following snippet which will be explained later, shows how to combine client and side views:

.index.js
[source, javascript]
----
import {Router} from '@vaadin/router';
import {Flow} from '@vaadin/flow-frontend/Flow';

const router = new Router(document.querySelector('#outlet'));
const flow = new Flow({
  imports: () => import('../target/frontend/generated-flow-imports')
});

router.setRoutes([
  // client-side views
  {
    path: '/categories',
    component: 'app-categories'
  },
  // pass all unmatched routes to server-side
  flow.route
]);
----

The `@vaadin/router` module facilitates navigation when client and server views are combined in the same application, as well as when common layouts are used in the page.

The glue for mixing views is the `@vaadin/flow-frontend/flow` JavaScript module which allows lazy initialization of Flow and navigation to server views.

== Prerequisites

 - Vaadin 15+ is needed to enable <<client-side-bootstrapping#,Client Side Bootstrapping>> and use the Flow client module.
 - Vaadin Router link:https://github.com/vaadin/vaadin-router/releases/[1.4.3+] is needed to properly handle client and server views.

[NOTE]
If your Vaadin starter project is already configured for client-side bootstrapping, you can skip _installation_ and _usage_ sections in this article.

== Vaadin Router

Vaadin Router is a small yet powerful client-side router JavaScript library. It uses a widely adopted `express.js` syntax for routers (users/:id) to map URLs to views. It has all the features you expect from a modern router: async route resolution, animated transition, child routes, navigation guards, redirects, and more.

Vaadin router works with Web Components regardless of how they are created, it also offers a JavaScript API for regular HTML elements.

=== Installation

It is available as an `npm` package. Run the following command to add the dependency to your project:

[source,bash]
----
$ npm install --save @vaadin/router
----

=== Usage

Once vaadin router is available in your dependency tree, add it to the `index.js` (or `index.ts`) file by using the `import` statement, then create a router instance by passing the outlet element in the `index.html` file:

.index.html
[source, html]
----
<html>
  <body>
    <h1>My App</h1>
    <div id="outlet"></div>
  </body>
</html>
----


.index.js
[source, javascript]
----
import {Router} from '@vaadin/router';
const outlet = document.querySelector('#outlet');
const router = new Router(outlet);
----

Router configuration is done by using a set of routes that map URL paths to components.

Vaadin Router goes through the routes until the first match is found, then it takes the instance of the route element to be inserted in the router outlet (replacing any pre-existing element).

[source, javascript]
----
router.setRoutes([
  {
    path: '/help',
    component: 'app-help',
  },
  {
    path: '/categories',
    component: 'app-categories'
  }
]);
----

== Layouts

When using client routing, it is possible to compose the page layout without server intervention, so as the application shell can be shown when in offline mode.

Vaadin Router enables layout containers by using the `children` property during the configuration:

[source, javascript]
----
router.setRoutes([
  {
    path: '/',
    component: 'app-layout'
    children: [
      {
        path: '/help',
        component: 'app-help',
      },
      {
        path: '/categories',
        component: 'app-categories'
      }
    ]
  }
]);
----

== Vaadin Flow Client

Flow provides a client module which acts as a bridge between client router and server routes.

Even though it is possible to integrate Flow with any JavaScript based routing solution, we recommend using Vaadin Router as introduced in the previous section.

=== Installation

Flow client module is not available in `npm` repositories, however it is automatically added to the `node_modules` folder when your Java project depends on Vaadin 15+

=== Usage

First, you have to import the module, and then you have to create the `Flow` instance.

At this point, it is needed to specify the location to the Flow generated file with the imports for Java views, typically `/target/frontend/generated-flow-imports.js` in a Vaadin maven project.

Notice that the `import()` function should be used in order to lazy load Flow dependencies the first time the user navigates to a server-side view.

[source, javascript]
----
import {Flow} from '@vaadin/flow-frontend/Flow';
const flow = new Flow({
  imports: () => import('../target/frontend/generated-flow-imports')
});
----

Finally, make Vaadin Router pass all unmatched paths to Flow server by adding `flow.route` at the end of the router configuration block:

[source, html]
----
<html>
  <body>
    <h1>My App</h1>
    <a href="categories">Categories</a>
    <a href="reviews">Reviews</a>
    <div id="outlet"></div>
  </body>
</html>
----

[source, javascript]
----
import {Router} from '@vaadin/router';
import {Flow} from '@vaadin/flow-frontend/Flow';

const router = new Router(document.querySelector('#outlet'));
const flow = new Flow({
  imports: () => import('../target/frontend/generated-flow-imports')
});

router.setRoutes([
  // client-side views
  {
    path: '/categories',
    title: 'categories',
    component: 'app-categories'
  },
  // pass all unmatched routes to server-side
  flow.route
]);
----

== Router Navigation Events

The router executes callbacks on each view to check if the navigation must continue, be postponed or redirected. The way to implement navigation controllers differs depending on whether the view is on the client or server side.

=== Vaadin Router navigation lifecycle (client-side views)

When returning an element or Web Component in a client view, developer might implement the following lifecycle methods:

- `onBeforeEnter(location, commands, router)` is executed before the outlet container is updated with the new element. At this point, user can cancel the navigation.
- `onAfterEnter(location, commands, router)` is executed after the new element has been attached to the outlet. he difference between this method and `onBeforeEnter` is that when this method is executed, there is no way to abort the navigation.
- `onBeforeLeave(location, commands, router)` is executed before the previous element is going to be detached. Navigation can be cancelled at this point.
- `onAfterLeave(location, commands, router)` is executed before the element is going to be removed from the DOM. When this method is executed, there is no way to abort the navigation.

During the execution of `onBeforeEnter` and `onBeforeLeave` callbacks, user might postpone navigation by returning `commands.prevent()`, but only in `onBeforeEnter`, navigation can be redirected by returning `commands.redirect(path)`.

[NOTE]
Lifecycle callbacks are asynchronous.

The following snippets show how to cancel navigation in a Web Component

[source, javascript]
.my-demo.js
----
class MyView extends HTMLElement {
  onBeforeEnter(location, commands, router) {
    return location.pathname === '/cancel' ? commands.prevent() : {};
  }
customElements.define('my-view', MyView);

router.setRoutes([
  {
    path: '/view1',
    component: 'my-view'
  }
]);
----

For more information visit vaadin router link:https://vaadin.github.io/vaadin-router/vaadin-router/#/classes/WebComponentInterface[API documentation]

=== Flow Router navigation lifecycle (server-side views)

For server-side views routing events are handled as described in the Vaadin <<../routing/tutorial-routing-lifecycle#,Navigation Lifecycle>> chapter.

The way to interact with lifecycle events in Java is by implementing the following interfaces:

- Any attached Components implementing `BeforeEnterObserver` will receive an event before a new navigation state is entered. There is the possibility to reroute or forward to another navigation target.
- Attached components implementing `BeforeLeaveObserver`  will receive an event before leaving the current navigation state. Navigation can be postponed, or rerouted or forwarded to another target.
- Components implementing `AfterNavigationObserver` will receive an event after all navigation tasks have resolved.


In the following example, navigation is cancelled when the view is dirty.

[source, java]
----
public class MyView extends Div implements BeforeLeaveObserver {
    @Override
    public void beforeLeave(BeforeLeaveEvent event) {
        if (this.isDirty()) {
            event.postpone();
        }
    }

    private boolean isDirty() {
        return true;
    }
}
----

[NOTE]
Rerouting from server to client side is not supported yet.
